线程池：ThreadPoolExecutor

*********************一、new Thread()的弊端*********************
1.不优雅
2.new对象消耗资源，性能差
3.缺乏管理
4.Thread类缺乏很多功能，如调度、定时任务、中断和监控等
5.由于代码的问题可能无限制new Thread()相互竞争，造成系统宕机或内存溢出（OOM）

*********************二、线程池的优势*********************
1.优雅
2.重用存在的线程，大大减少对象的创建、消亡的开销，性能高
3.可有效控制最大并发线程数，提高系统资源利用率，避免资源竞争，避免阻塞
4.提供许多强大的功能，如调度、定时任务、单线程控制和并发控制等

*********************三、线程池的基本参数*********************
1.corePoolSize：核心工作线程数
2.maximumPoolSize：最大线程数
3.workQueue：阻塞队列（存储等待执行的任务）

当线程数没有达到corePoolSize，线程池会创建新线程来处理新任务，即使有空闲线程
当线程数达到corePoolSize，没有达到maximumPoolSize，新来的任务将放入队列。当队列满了，线程池将创建新线程来处理任务
当线程数达到maximumPoolSize且没有空闲线程，并且队列也满了，则根据【拒绝策略】来处理新任务

当corePoolSize = maximumPoolSize，线程池大小固定

4.keepAliveTime：线程空闲时的生存时间
当线程空闲时间达到keepAliveTime，守护线程会将此线程销毁
5.unit：keepAliveTime的时间单位
6.threadFactory：创建线程的工厂
7.rejectHandler：拒绝策略
当线程数量达到maximumPoolSize，并且队列满了，线程池将根据此参数来处理新任务
(1)抛出异常（默认）
(2)使用调用者所在的线程来执行任务
(3)丢弃队列中最靠前的任务来执行此任务
(4)直接抛弃此任务

*********************四、线程池的弊端*********************
线程池好用且易用，但不是随便都能用
当任务的执行时间已经很接近任务的调度时间时，线程池的效率会大大降低
甚至不用线程池的效率更高

*********************五、线程池的状态*********************
1.running
队列可以接受新任务，线程池中的线程也可以处理任务
2.shutdown - call shutdown()
队列不再接受新任务，线程池中的线程继续处理队列中已经接受的任务
3.stop - call shutdownNow()
队列不再接受新任务，线程池中的线程也不再处理队列中已经接受的任务，并且正在处理任务的线程也会马上停止处理
4.tidying
阻塞队列为空，线程池中的线程数量为0，则进入此状态
5.terminated(结束) - call terminated()
terminated()方法什么都不做，调用之后则进入此状态

*********************六、主要方法*********************
(1)基础方法
1.execute()
提交任务，调度线程，没有结果返回
2.submit()
提交任务，调度线程，有结果返回（future）
3.shutdown()
关闭线程池，等待正在执行的任务
4.shutdownNow()
关闭线程，并且停止正在执行的任务
(2)监控方法
1.getTaskCount()
获取已执行和未执行的任务总数
2.getCompletedTaskCount()
获取已完成的任务总数
3.getPoolSize()
获取当前线程数量
4.getActiveCount()
获取正在执行任务的线程数量
PS：监控方法主要用于监控线程池的运行状态，比如可以做定时任务，每分钟获取这些状态，展示到图表中

*********************七、线程池类结构*********************
Executor(I) <-- ExecutorService(I) <-- ScheduledExecutorService(I) <-- ScheduledThreadPoolExecutor(C) <-- Executors(C)

*********************八、Executors框架接口*********************
1.Executors.newCachedThreadPool()
池中工作线程数量可变，需要新线程时，回收空闲线程，如果没有可回收的，就创建新线程
2.Executors.newFixedThreadPool()
池中工作线程数量不变，当线程不够用时，任务将在队列中等待
3.Executors.newScheduledThreadPool()
池中工作线程数量不变，任务可周期性执行、定时执行
4.Executors.newSingleThreadPool()
池中只有一个线程，保证了单线程，保证任务按一定顺序执行，可以知道执行策略（如：先入先出，优先级）

*********************九、线程池的配置优化*********************
1.CPU密集型任务：尽量压榨CPU，线程数参考值可以设为CPU数+1
2.IO密集型任务：线程数参考值可设为CPU数*2

如果想降低系统资源的消耗（主要是CPU使用率），可以设置较大的队列容量和较小的线程池容量。这样可以降低线程池的吞吐量
如果想缓解经常阻塞的队列，可以设置较大的线程池容量和较小的队列容量。这样可以提高线程池的吞吐量、CPU使用率

但是如果线程池容量设置得过大，会引起很大的并发负担，到时候线程的调度也是问题，甚至会降低线程池的吞吐量