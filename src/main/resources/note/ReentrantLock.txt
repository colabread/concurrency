********************一、ReentrantLock和synchronized的对比********************
1、可重入性
两者都是可重入锁，即可在锁中再加锁
每加一次锁，锁计数器+1，每释放一次锁，计数器-1，当计数器为0时才释放锁住的对象（临界资源）
2、灵活性
前者由开发者代码控制，较为灵活
后者由jvm底层控制，不是那么灵活
3、公平性
ReentrantLock可以指定为公平锁或非公平锁，而synchronized只能是非公平锁
公平锁就代表先到达的线程先获得锁
4、锁的实现
前者由jdk实现，后者由jvm实现
5、性能的区别
后者相比于前者性能差很多，但自从synchronized引入偏向锁、自旋锁后性能大大提高甚至接近前者
在两者都可以的情况下，官方推荐使用synchronized，因为代码直观易于理解
synchronized的实现借鉴了ReentrantLock中的CAS技术

********************二、ReentrantLock独有的功能********************
1、可以指定为公平锁或非公平锁
2、提供Condition类，可以分组唤醒需要唤醒的线程，而synchronized只能随机唤醒一个或全部
3、提供了可以中断等待锁的线程的机制，即lock.lockInterruptibly()

当需要使用以上几种功能时，就必须选择ReentrantLock
如果不需要则视情况使用哪种

********************三、ReentrantReadWriteLock（悲观锁）********************
1、ReentrantLock的弊端：
普通的ReentrantLock完全不允许并发，无论是读操作和写操作，都必须等待锁被释放再获取锁，然后才能操作
在高并发的情况下性能非常低下

2、定义：
是JDK提供的一种读和写操作分开的锁，使得读和读可以并发
相比于普通的ReentrantLock性能提升了很多

3、使用场景：
对共享资源有读和写的操作，且写操作没有读操作那么频繁

4、它的两个锁
一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称为排他锁
线程进入读锁的前提条件：
（1）没有其他线程的写锁
（2）没有写请求或者调用写请求的线程和持有当前读锁锁的线程是同一个，也就是说在读锁内部可以再加写锁

线程进入写锁的前提条件：
（1）没有其他线程的读锁
（2）没有其他线程的写锁

当读锁被某个线程持有时，其他线程不能持有其写锁，但可以共享这个读锁
当写锁被某个线程持有时，其他线程即不能持有其写锁，也不能持有其读锁

资料链接：http://www.cnblogs.com/xiaoxi/p/9140541.html

********************三、StampedLock（乐观锁）********************
1、ReentrantReadWriteLock的弊端：
读写锁虽然分离了读和写的功能，使得读与读之间可以完全并发，但是读和写之间依然是冲突的，读锁会完全阻塞写线程
它使用的依然是悲观锁策略，如果有大量的读线程，那么极有可能引起写线程的饥饿（写线程永远无法获取写锁进行写操作）

2、定义：
StampedLock是JDK8引入的一种新的锁机制，是读写锁的改进版本
它提供了一种乐观锁的读策略，使得读锁完全不会阻塞写线程
这种乐观锁非常类似于无锁的操作

3、实现原理：
当读锁被持有，若此时有写操作，读锁并不会阻塞写线程，而是在读取数据之后返回数据的版本票据（stamp）
在返回数据之前对比这个stamp和当前真实的stamp，如果不同代表在读取之后，返回之前有线程进行了写操作，那么开始自旋获取（循环获取）
直到获取到那个stamp和真实的stamp值相同的值